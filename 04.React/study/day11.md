# 📘 학습 일지

## Session ID vs Token

- HTTP는 상태를 기억하지 않는(stateless) 프로토콜이라서, 로그인 여부를 서버가 따로 기억해줘야 한다.
- 이때 방법이 `세션 ID 방식` vs `토큰 방식(JWT 등)` 두 가지가 존대한다

| 구분      | 세션 ID                    | JWT 토큰                            |
| --------- | -------------------------- | ----------------------------------- |
| 저장 위치 | 서버(DB/메모리)            | 클라이언트(localStorage, cookie 등) |
| 서버 부담 | 많음 (상태 계속 저장)      | 적음 (토큰 자체가 정보)             |
| 확장성    | 낮음                       | 높음 (분산 서버에 적합)             |
| 보안      | 세션 하이재킹 위험         | 토큰 유출 시 권한 탈취 위험         |
| 만료      | 서버가 직접 만료 처리 가능 | 만료까지 유효, 강제 만료 어려움     |

👉 세션 = “번호표(서버가 명단을 관리)” / 토큰 = “QR 입장권(정보 자체가 티켓 안에 있음)”

## Axios Interceptors

Axios는 요청과 응답을 가로채서 공통 로직을 넣을 수 있는 기능을 제공한다.<br/>
(토큰 주입, 에러 처리, 로그 출력 같은 걸 전역에서 처리 가능!)

## Response Interceptor

- fulfilled(response): 요청이 성공했을 때 실행 (`HTTP 2xx`)
- rejected(error): 실패했을 때 실행 (`401`, `500` 등) → 보통 에러 처리, 토큰 갱신 로직에 활용

## Request Interceptor

- fulfilled(config): 요청이 서버로 가기 직전에 실행되며, 보통 이때 `Authorization` 헤더 주입 같은 작업
- rejected(error): 요청 설정 단계에서 오류 발생 시 실행됨. (거의 미사용)

# 💡 느낀 점

- 세션과 토큰의 차이를 정리하면서, 왜 대규모 서비스에서 토큰 기반 인증을 선호하는지 이해할 수 있었다.
- Axios Interceptors는 마치 검문 같은 느낌이었다. 그리고 모든 요청/응답을 통일된 방식으로 처리할 수 있어서 편리했다.
- `config.auth !== false` 패턴이 특히 깔끔했으며, 요청마다 “이건 인증 필요? 필요 없음?”을 간단히 구분 가능.
- ESLint의 display-name 에러도 디버깅과 추적성을 높여주는 중요한 규칙이라는 걸 알았다.
