# React 주요 내장 Hook & API

## useEffect

> 컴포넌트와 외부 세계(브라우저 API, 서버, 이벤트 리스너 등)를 동기화할 때 쓰는 Hook.

### 특징

- 화면에 렌더링이 끝난 뒤 실행됨.
- 의존성 배열에 따라 실행 시점이 달라짐:
  - `[]`: 마운트 시 한 번만 실행
  - `[a, b]`: a나 b 값이 바뀔 때 실행
  - `생략`: 매 렌더마다 실행 (거의 안 씀)
- `return () => { ... }` 로 clean-up 코드 작성 가능 (ex: 타이머 해제, 이벤트 제거)

### 주의점

- 의존성 배열을 잘못 주면 무한 루프 발생 😱
- 특히 매번 새로운 참조(배열/객체)를 넣거나 상태를 매번 갱신할 때 조심!

## useMemo

> 값 계산을 메모이제이션하는 Hook으로,“필요할 때만 다시 계산, 아니면 지난 결과 재사용!”

### 예시 상황

- **폼/스키마 검증**: 매 렌더마다 스키마가 새로 만들어지는 문제 방지
- **상품 리스트 필터링**: 수천 개 상품을 매번 필터링하지 않고, 조건이 바뀔 때만 재계산
- **차트 옵션 캐싱**: 불필요한 리렌더 방지
- **자동완성 검색**: 비싼 전처리를 캐싱해 입력 지연 줄이기

## useCallback

> 함수를 메모이제이션하는 Hook으로, 특정 값이 바뀌지 않는 한 같은 함수 참조 유지!

- 함수는 렌더마다 새로 만들어지는데 이게 자식 컴포넌트(`React.memo`)에 `props`로 전달되면, `props`가 달라졌다고 생각해서 불필요한 리렌더 발생.
- 이때 `useCallback`을 쓰면 함수 참조가 고정돼서 이런 문제 해결 가능.

## memo

> 컴포넌트 자체를 메모이제이션하고, props가 바뀌지 않았다면 리렌더를 건너뜀.

- `memo(SomeComponent, arePropsEqual)` 형태로, props 비교 로직을 커스터마이징할 수도 있음.
- 예: 배열 props의 길이와 값이 동일하다면 리렌더링 건너뛰기

## Hook 조합 예시

- `useCallback` + `memo`를 같이 쓰면, 부모가 리렌더되더라도 자식이 불필요하게 렌더되지 않음.

```jsx
const Child = memo(({ onClick }) => {
  console.log('Child 렌더링');
  return <button onClick={onClick}>자식 버튼</button>;
});

function App() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    console.log('자식 버튼 클릭');
  }, []);

  return (
    <>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>부모 카운트 증가</button>
      <Child onClick={handleClick} />
    </>
  );
}
```

# 💡 느낀 점

- `useEffect`는 단순히 “렌더 후 실행”이 아니라, React 상태와 외부 시스템을 연결해주는 다리라는 점이 핵심!
- 의존성 배열을 대충 쓰면 바로 무한 루프에 빠질 수 있다는 걸 보고, 항상 “언제 실행돼야 하지?”를 먼저 생각해야겠다.
- `useMemo` / `useCallback`은 무조건 성능 최적화용이라기보다는, 불필요한 연산이나 렌더를 줄여주는 안전장치 같은 느낌이었다.
- `memo`까지 조합하면 앱 성능이 많이 좋아지겠지만, 너무 남발하면 코드가 복잡해질 수 있어서 적재에만 써야겠다.
- 결국 중요한 건 의존성 관리와 실행 시점 파악. 이 부분을 확실히 이해해야 React Hook을 제대로 쓸 수 있을 것 같다!
