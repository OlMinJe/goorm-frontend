# 📘 알고리즘 & 자료구조 기초, Big-O

## 알고리즘이란?

> 알고리즘 = 문제를 해결하기 위한 단계별 절차<br/>
> 같은 문제라도 <i>더 빠르고 더 적은 자원</i>으로 푸는 방법이 좋은 알고리즘!

## 왜 알고리즘을 배울까?

1. **효율적인 문제 해결**: 같은 문제도 더 빠르게 해결 가능
2. **성능 최적화**: 사용자 경험 향상 (앱이 버벅이지 않음)

👉 그냥 React 문법만 알면 작은 데이터까진 괜찮지만, “데이터가 커질수록도 잘 도는 코드”를 만들려면 알고리즘/자료구조가 필수!

## 자료구조

> **자료구조 = 데이터를 저장·조직화하는 방식**<br/>
> 알고리즘은 이 구조 위에서 “어떻게 처리할지”를 정의.

### 분류

< 분류 >

| 분류            | 자료구조                      | 정의 / 개념                                |
| --------------- | ----------------------------- | ------------------------------------------ |
| **단순 구조**   | 정수, 실수, 문자, 문자열      | 더 이상 쪼개지지 않는 기본 데이터 타입     |
|                 | 구조체(Struct) / 객체(Object) | 서로 다른 타입을 묶어 관리하는 단위 데이터 |
| **선형 구조**   | 배열(Array)                   | 동일 타입 데이터를 연속된 메모리에 저장    |
|                 | 연결 리스트(Linked List)      | 데이터 + 다음 노드 주소로 연결             |
|                 | 스택(Stack)                   | LIFO (후입선출) 구조                       |
|                 | 큐(Queue)                     | FIFO (선입선출) 구조                       |
|                 | 덱(Deque)                     | 양쪽에서 삽입/삭제 가능한 큐               |
| **비선형 구조** | 트리(Tree)                    | 계층적 구조 (부모-자식 관계)               |
|                 | 이진 탐색 트리(BST)           | 왼쪽 < 부모 < 오른쪽 규칙 가진 트리        |
|                 | 힙(Heap)                      | 우선순위 기반 이진 트리                    |
|                 | 그래프(Graph)                 | 정점(Vertex)과 간선(Edge)으로 연결된 구조  |

- 선형 구조: “줄 서기”처럼 순서대로
- 비선형 구조: “조직도/지하철 노선도”처럼 계층, 연결이 중요

## 시간 복잡도(Big-O)

> 입력 크기 `n`이 커질 때 실행 시간이 얼마나 늘어나는지를 나타낸 표기

- `O(1)`: 한 번에 끝 (상수 시간)
- `O(log n)`: 반씩 줄여가며 찾음 (이진 탐색)
- `O(n)`: 줄 전체를 한 번 훑음 (선형)
- `O(n²)`: 이중 반복 (조합/쌍 비교 등)

< 예시 >

- `O(log n)`: 100만 → 약 20번 정도! (절반씩 제거하니 느리게 늘어남)
- `O(n²)`: 데이터 조금만 커져도 폭발적으로 느려짐

```js
// O(1)
function getFirst(arr) {
  return arr[0];
}

// O(n)
function printAll(arr) {
  for (const x of arr) console.log(x);
}

// O(n^2)
function printPairs(arr) {
  for (const a of arr) for (const b of arr) console.log(a, b);
}

// O(log n) - 이진 탐색(정렬된 배열)
function binarySearch(arr, target) {
  let l = 0,
    r = arr.length - 1;
  while (l <= r) {
    const m = (l + r) >> 1;
    if (arr[m] === target) return m;
    arr[m] < target ? (l = m + 1) : (r = m - 1);
  }
  return -1;
}
```

## 알고리즘의 필수 요소

### 명확성

누구나 같은 결과를 가져야 한다

### 유한성

반드시 끝나야 한다.(무한 루프X)

### 입력/출력

최소 1개 이상 입력/출력

### 효율성

현실적으로 실행 가능해야 하면, 자원 낭비가 없어야 한다.
